---
name: yiyan-rules
description: 易研项目开发规范 - Vue3 + TypeScript + Arco Design + Spring Boot 微服务架构

---

## 项目概述

### 1. yiyan-hukx-fronted（微服务前端 Demo - 主要开发项目）
**技术栈版本：**
- Vue 3.2.40 + TypeScript 4.8.4 + Vite 3.2.5
- Arco Design Vue 2.40.0
- Pinia 2.0.23（状态管理）
- Vue Router 4.0.14
- Vue I18n 9.2.2（国际化）
- 其他核心依赖：
  - ECharts 5.4.0 + vue-echarts 6.2.3（图表）
  - @wangeditor/editor 5.1.23（富文本编辑器）
  - bpmn-js 17.6.4（流程设计器）
  - dayjs 1.11.5（日期处理）
  - lodash 4.17.21（工具函数）
  - vue-konva 3.2.6 + konva 10.0.12（图形绘制）

**项目结构：**
```
src/
├── api/              # API 接口（按模块组织：bpm、system、form、hr等）
├── components/       # 业务组件（约 50 个）
├── views/            # 页面视图（约 107 个文件）
├── router/           # 路由配置（模块化路由）
├── store/            # Pinia 状态管理（模块化）
├── hooks/            # 组合式函数（可复用逻辑）
├── utils/            # 工具函数
├── types/            # TypeScript 类型定义
├── constants/        # 常量定义
├── locale/           # 国际化资源
└── assets/           # 静态资源

config/               # Vite 配置文件
├── vite.config.base.ts    # 基础配置
├── vite.config.dev.ts     # 开发环境配置
└── vite.config.prod.ts    # 生产环境配置
```

**开发配置：**
- 开发服务器：`localhost`，自动打开浏览器
- 代理配置（vite.config.dev.ts）：
  - JPAAS 服务：`http://hukx-Macmini.local:9900`
    - `/api-bpm` → JPAAS BPM 服务
    - `/api-form` → JPAAS Form 服务
    - `/api-system` → JPAAS System 服务
    - `/api-user` → JPAAS User 服务
  - 易研平台：`http://hukx-Macmini.local:39996`
    - `/api` → 易研平台其他服务
  - 人事服务：`http://localhost:10008`
    - `/api/hr` → 人事服务

**代码规范工具：**
- ESLint 8.25.0（Airbnb 规范 + TypeScript + Vue3）
- Prettier 2.7.1（代码格式化）
- Stylelint 14.13.0（样式格式化）
- Husky 8.0.1 + lint-staged 13.0.3（Git 提交前检查）
- Commitlint 17.1.2（Commit 消息规范，遵循 Conventional Commits）
- vue-tsc 1.0.14（TypeScript 类型检查）
### 2. yiyan-hukx-fronted-locally（单机版前端 Demo - 参考项目）
**技术栈：**
- 与微服务版本基本相同
- **额外包含：**
  - `@vue-office/docx` 1.6.3（Word 文档预览）
  - `@vue-office/excel` 1.7.14（Excel 文档预览）
  - `@vue-office/pdf` 2.0.10（PDF 文档预览）
  - `@vue-office/pptx` 1.0.1（PPT 文档预览）
  - `konva` 10.0.12 + `vue-konva` 3.2.6（图形绘制）

**项目规模：**
- 视图文件：约 240 个（vs 微服务版 107 个）
- API 文件：约 90 个（vs 微服务版约 40 个）
- 组件：约 82 个（vs 微服务版约 50 个）

**特殊内容：**
- `guide/` 目录：开发文档和指南
- `各类功能后端/` 目录：包含多个业务模块的后端代码和文档
  - 人事功能
  - 党建积分
  - 待办清单
  - 文件传阅
  - 桶装水管理
  - 科室计划管控
  - 部门计划

### 3. my-dxe-backed（微服务后端项目）
**项目结构（Maven 多模块）：**
```
my-dxe-backed/
├── yiyan-demo-api/      # API 接口定义模块（DTO、VO、接口定义）
├── yiyan-demo-biz/      # 业务逻辑实现模块（Controller、Service、DAO、Entity）
├── yiyan-demo-server/   # 服务启动模块（启动类、配置文件）
└── code-generator/      # 代码生成器模块
```

**技术栈版本：**
- Spring Boot 2.3.12.RELEASE
- Spring Cloud Hoxton.SR12
- Spring Cloud Alibaba 2.2.5.RELEASE
- MyBatis / MyBatis Plus
- Lombok 1.18.34 + MapStruct 1.6.2（对象转换）
- Java 1.8

**微服务组件：**
- 服务注册与发现：Nacos
- 配置中心：Nacos
- API 网关：Spring Cloud Gateway
- 服务调用：OpenFeign
- 服务熔断：Sentinel
- 链路追踪：SkyWalking
- 分布式事务：Seata
- 定时任务：XXL-Job

**中间件配置：**
- 数据库：MySQL 5.7（`hukx-Macmini.local:3307`，数据库：`240_hr`）
- Redis：`hukx-Macmini.local:6379`（密码：yiyan）
- RabbitMQ：`hukx-Macmini.local:5672`（用户名/密码：yiyan，虚拟主机：/yiyan）
- Nacos：`hukx-Macmini.local:8848`（namespace: platform，用户名/密码：nacos）
- MinIO：`hukx-Macmini.local:9000`（存储服务）

**后端代码结构（yiyan-demo-biz）：**
```
src/main/java/com/cac/demo/
├── controller/     # 控制器层（REST API）
├── service/       # 服务层（业务逻辑）
├── dao/           # 数据访问层（MyBatis Mapper）
├── entity/        # 实体类（数据库表映射）
├── vo/            # 视图对象（VO - View Object）
├── convert/       # 对象转换器（MapStruct）
└── config/        # 配置类
```

**业务模块示例：**
- `operatelog`：操作日志功能（包含完整的 Controller、Service、DAO、Entity、VO、Convert 等）

**项目关联关系：**
- 前端与后端对接：
  - 前端 OAuth：`appKey: hukx-client` / `appSecret: hukx`
  - 后端 OAuth 配置：`client-id: hukx-client`，`client-secret: hukx`
  - 前端代理指向后端服务：`http://hukx-Macmini.local:39996`
- 开发流程：
  - **主要开发项目**：`yiyan-hukx-fronted`（微服务前端）
  - **参考实现项目**：`yiyan-hukx-fronted-locally`（功能更全，可作为参考）
  - **后端服务**：`my-dxe-backed`


---

## 前端编码要求

### 1. API 请求规范

#### 1.1 请求工具说明
项目封装了多个请求工具，位于 `@/utils/request/` 目录：
- **`request.ts`**：易研平台标准请求工具（返回格式：`{ success, message, code, data }`，成功判断：`code === 200`）
- **`requestJpaas.ts`**：JPAAS 平台请求工具（返回格式：`{ success, message, code, data, result }`，成功判断：`success ?? true`）
- **`security.ts`**：安全相关请求工具（不添加 token）
- **`requestForFile.ts`**：文件下载请求工具
- **`requestFileHeaders.ts`**：带自定义请求头的文件请求工具

**重要规则：**
- ✅ **必须使用**项目封装的请求工具，不要自己二次封装 axios
- ❌ **禁止直接使用** axios
- ✅ 根据后端服务选择对应的请求工具：
  - JPAAS 服务（`/api-bpm`、`/api-form`、`/api-system`、`/api-user`）→ 使用 `requestJpaas`
  - 易研平台服务（`/api`）→ 使用 `request`
  - 文件相关 → 使用 `requestForFile` 或 `requestFileHeaders`

#### 1.2 API 接口文件规范
- 所有 API 接口文件参考 `@/api/bpm` 目录下的标准接口写法
- API 文件按业务模块组织：`src/api/{模块名}/`
- 每个 API 文件导出具体的接口函数，函数必须有 JSDoc 注释
- 接口函数使用 `async/await`，返回类型为 `Promise<HttpResponse<T>>`

**API 接口示例：**

```typescript
// src/api/hr/department.ts
import request from '@/utils/request/request';

/**
 * 获取部门树数据
 */
export function getDepartmentTree() {
  return request.get<Department[]>('/api/hr/department/tree');
}
```

**在组件中使用 API：**
```typescript
  /**
   * 获取部门树数据
   */
  const getDepartmentTree = async () => {
    try {
      loading.value = true;
      const { data } = await departmentApi.getDepartmentTree();
      departmentList.value = data || [];
      // 默认展开第一层
      expandedKeys.value = data
        .map((dept) => dept.deptId)
        .filter((id): id is string => !!id);
    } catch (error) {
      console.error('获取部门数据失败:', error);
      Message.error('获取部门数据失败');
    } finally {
      loading.value = false;
    }
  };
```

#### 1.3 分页接口规范
- 分页请求参数：`pageNum`（当前页）、`pageSize`（每页数量）
- 分页响应格式：`{ list: T[], total: number }`
- 列表数据在 `list` 属性中，总数在 `total` 属性中

**分页获取代码示例：**
```typescript
    /**
 * 分页获取员工列表
   */
  const fetchData = async () => {
    try {
      loading.value = true;
      const { data } = await employeeApi.getEmployeePage({
        pageNum: pagination.current,
        pageSize: pagination.pageSize,
        userName: searchKey.value,
        departmentId: filterDept.value,
      });
      employeeList.value = data.list || [];
      pagination.total = data.total;
  } catch (error) {
    console.error('获取员工列表失败:', error);
    Message.error('获取员工列表失败');
    } finally {
      loading.value = false;
    }
  };
```

### 2. 组件开发规范

#### 2.1 Arco Design 组件使用
- ✅ 所有 Arco Design 的图标已全局注册，**无需二次引入**，直接使用即可
- ✅ 组件使用 `<script setup lang="ts">` 语法
- ✅ 使用 Composition API，避免 Options API

**图标使用示例：**
```vue
<template>
  <icon-plus />
  <icon-edit />
  <icon-delete />
</template>
```

#### 2.2 TypeScript 类型定义
- ✅ 所有组件 props、emits 必须提供完整的 TypeScript 类型注解
- ✅ 禁止使用 `any` 类型（ESLint 配置允许，但应尽量避免）
- ✅ 使用类型守卫（Type Guards）进行类型判断
- ✅ 接口类型定义放在 `src/types/` 或与组件同级的 `types.ts` 文件中

**类型定义示例：**
```typescript
// types.ts
export interface Employee {
  id?: string;
  userCode: string;
  userName: string;
  departmentId?: string;
  mobile?: string;
}

// 组件中使用
import type { Employee } from '@/types';
const employee = ref<Employee | null>(null);
```

### 3. ESLint 代码规范

#### 3.1 语法规范
- ✅ **禁止使用** `++` 和 `--`，使用 `+= 1` 和 `-= 1` 代替
- ✅ 使用 `const` 优先于 `let`，避免使用 `var`
- ✅ 函数必须有明确的返回类型
- ✅ 未使用的变量使用 `_` 前缀（如 `_unusedVar`）

**示例：**
```typescript
// ❌ 错误
let count = 0;
count++;
count--;

// ✅ 正确
let count = 0;
count += 1;
count -= 1;
```

#### 3.2 Vue 组件规范
- ✅ 组件名使用 PascalCase（多词组件名）
- ✅ Props 定义使用 `defineProps<T>()` 泛型语法
- ✅ Emits 定义使用 `defineEmits<T>()` 泛型语法
- ✅ 禁止使用 `$emit` 字符串形式
- ✅ 禁止使用 `$parent`、`$children`、全局事件总线

### 4. 组件通信规范

#### 4.1 父子组件通信
- ✅ 父子通信**仅使用** `defineProps` 和 `defineEmits`，且必须提供完整的 TypeScript 类型注解
- ❌ **禁止使用** `$emit` 字符串、`$parent`、`$children`、全局事件总线

**Props 和 Emits 定义示例：**
```typescript
  // Child.vue
interface Props {
  /** 双向绑定的值 */
    modelValue?: string;
  /** 是否禁用 */
    disabled?: boolean;
  /** 标题 */
  title?: string;
}

const props = withDefaults(defineProps<Props>(), {
  disabled: false,
  title: '',
});

interface Emits {
  /** 更新 modelValue */
    (e: 'update:modelValue', value: string): void;
  /** 确认事件 */
    (e: 'confirm'): void;
  /** 取消事件 */
  (e: 'cancel'): void;
}

const emit = defineEmits<Emits>();
```

#### 4.2 v-model 双向绑定
- ✅ 所有可被表单使用的组件**必须支持** `v-model`（即 `modelValue` prop + `update:modelValue` emit）
- ✅ 永远不要直接修改 props；状态变更必须通过 emit 通知父组件

**v-model 实现示例：**
```vue
      <!-- Parent.vue -->
<template>
    <CustomInput v-model="inputValue" />
</template>

<script setup lang="ts">
const inputValue = ref('');
</script>

    <!-- CustomInput.vue -->
<template>
  <a-input
    :model-value="props.modelValue"
    @input="handleChange"
  />
</template>

    <script setup lang="ts">
    const props = defineProps<{ modelValue: string }>();
    const emit = defineEmits<{ (e: 'update:modelValue', val: string): void }>();

    const handleChange = (val: string) => {
      emit('update:modelValue', val);
    };
    </script>
  ```

#### 4.3 多 prop 双向绑定
- ✅ Vue 3 支持多个 `v-model:xxx`，用于多个值的双向绑定

**多 v-model 示例：**
```vue
<!-- Parent.vue -->
<DatePicker
  v-model:start="startDate"
  v-model:end="endDate"
/>

<!-- DatePicker.vue -->
<script setup lang="ts">
const props = defineProps<{
  start?: string;
  end?: string;
}>();

const emit = defineEmits<{
  (e: 'update:start', value: string): void;
  (e: 'update:end', value: string): void;
}>();
</script>
```

#### 4.4 复杂对象更新
- ✅ emit 整个新对象（避免 mutate prop）
- ✅ 使用展开运算符创建新对象

**复杂对象更新示例：**
```typescript
const handleConfigChange = (newField: string) => {
  emit('update:config', {
    ...props.config,
    newField,
  });
};
```

#### 4.5 事件命名规范
- ✅ 事件命名采用**驼峰命名**方式（camelCase）
- ❌ **不要使用**短横线命名（kebab-case）

**事件命名示例：**
```typescript
// ✅ 正确
    const handleToggleEnabled = (config: ImportConfigVO, enabled: boolean) => {
    emit('toggleEnabled', config, enabled);
  };

// ❌ 错误
emit('toggle-enabled', config, enabled);
```

#### 4.6 跨组件状态管理
- ✅ **业务状态**使用 Pinia 管理（放在 `src/store/modules/`）
- ✅ **UI 上下文**（如 Form 禁用状态）可使用 `provide/inject`，但 key 必须为 Symbol，且提供类型定义

**Pinia Store 示例：**
```typescript
// src/store/modules/user/index.ts
import { defineStore } from 'pinia';

interface UserState {
  id?: string;
  username?: string;
  avatar?: string;
}

export const useUserStore = defineStore('user', {
  state: (): UserState => ({
    id: undefined,
    username: undefined,
    avatar: undefined,
  }),
  getters: {
    userInfo(state: UserState): UserState {
      return { ...state };
    },
  },
  actions: {
    setInfo(partial: Partial<UserState>) {
      this.$patch(partial);
    },
  },
});
```

**provide/inject 示例：**
```typescript
// Parent.vue
import { provide, InjectionKey } from 'vue';

interface FormContext {
  disabled: boolean;
}

const formContextKey: InjectionKey<FormContext> = Symbol('formContext');

provide(formContextKey, {
  disabled: ref(false),
});

// Child.vue
import { inject } from 'vue';

const formContext = inject(formContextKey);
```

#### 4.7 Arco Design 组件对齐
- ✅ 自定义组件行为需与 Arco 官方组件保持一致
- ✅ 事件命名遵循 Arco 规范：`change`、`input`、`update:value` 等
- ✅ 表单集成方式与 Arco 组件保持一致

### 5. 路由配置规范

#### 5.1 路由文件组织
- 路由配置按模块组织在 `src/router/routes/modules/` 目录
- 基础路由定义在 `src/router/routes/base.ts`
- 路由类型定义在 `src/router/routes/types.ts`

#### 5.2 路由定义规范
```typescript
// src/router/routes/modules/hr.ts
import type { AppRouteRecordRaw } from '../types';

const routes: AppRouteRecordRaw[] = [
  {
    path: '/hr/employee',
    name: 'EmployeeManage',
    component: () => import('@/views/hr/employee/manage/index.vue'),
    meta: {
      title: '员工管理',
      requiresAuth: true,
    },
  },
];

export default routes;
```

### 6. 状态管理规范（Pinia）

#### 6.1 Store 模块化
- Store 按功能模块划分，放在 `src/store/modules/` 目录
- 每个模块包含：`index.ts`（Store 定义）、`types.ts`（类型定义）

#### 6.2 Store 定义规范
```typescript
// src/store/modules/app/index.ts
import { defineStore } from 'pinia';
import type { AppState } from './types';

export const useAppStore = defineStore('app', {
  state: (): AppState => ({
    menuCollapse: false,
  }),
  getters: {
    menuCollapsed(state: AppState): boolean {
      return state.menuCollapse;
    },
  },
  actions: {
    toggleMenu() {
      this.menuCollapse = !this.menuCollapse;
    },
  },
});
```

### 7. 样式规范

#### 7.1 CSS 预处理器
- ✅ 使用 Less 作为 CSS 预处理器
- ✅ 样式文件使用 `.less` 扩展名

#### 7.2 样式作用域
- ✅ 组件样式使用 `<style scoped lang="less">`
- ✅ 全局样式放在 `src/assets/style/` 目录

#### 7.3 样式命名规范
- ✅ 使用 BEM 命名规范或语义化命名
- ✅ 类名使用 kebab-case

### 8. 错误处理规范

#### 8.1 API 错误处理
- ✅ 所有 API 调用必须使用 `try-catch` 包裹
- ✅ 错误信息使用 `Message.error()` 提示用户
- ✅ 关键错误记录到 `console.error`

**错误处理示例：**
```typescript
const fetchData = async () => {
  try {
    loading.value = true;
    const { data } = await api.getData();
    dataList.value = data || [];
  } catch (error) {
    console.error('获取数据失败:', error);
    Message.error('获取数据失败，请稍后重试');
  } finally {
    loading.value = false;
  }
};
```

### 9. 代码注释规范

#### 9.1 函数注释
- ✅ 所有函数必须有 JSDoc 注释
- ✅ 注释包含：功能描述、参数说明、返回值说明

**函数注释示例：**
```typescript
/**
 * 获取部门树数据
 * @returns {Promise<Department[]>} 部门树数据
 */
const getDepartmentTree = async (): Promise<Department[]> => {
  const { data } = await departmentApi.getDepartmentTree();
  return data || [];
};
```

#### 9.2 组件注释
- ✅ 复杂组件在 `<script setup>` 顶部添加功能说明注释

### 10. Git 提交规范

#### 10.1 Commit Message 格式
- ✅ 遵循 Conventional Commits 规范
- ✅ 格式：`<type>(<scope>): <subject>`

**Commit 类型：**
- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `style`: 代码格式调整（不影响功能）
- `refactor`: 代码重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具链相关

**示例：**
```
feat(hr): 新增员工管理功能
fix(bpm): 修复流程审批bug
docs(readme): 更新项目说明文档
```

---

## 后端编码要求

### 1. 代码结构规范

#### 1.1 模块组织
- Controller 层：`controller/{模块名}/`
- Service 层：`service/{模块名}/`
- DAO 层：`dao/{模块名}/`
- Entity 层：`entity/{模块名}/`
- VO 层：`vo/{模块名}/`
- Convert 层：`convert/{模块名}/`

#### 1.2 命名规范
- Controller：`{模块名}Controller.java`
- Service：`{模块名}Service.java`（接口）、`{模块名}ServiceImpl.java`（实现）
- DAO：`{模块名}Mapper.java`
- Entity：`{模块名}.java`
- VO：`{模块名}VO.java`、`{模块名}PageVO.java` 等
- Convert：`{模块名}Convert.java`

### 2. 数据库规范

#### 2.1 MySQL 版本
- ✅ 使用 MySQL 5.7 版本
- ✅ SQL 语句必须符合 MySQL 5.7 语法规范

#### 2.2 字段命名
- ✅ 使用下划线命名（snake_case）
- ✅ 主键统一使用 `id`
- ✅ 创建时间：`create_time`，更新时间：`update_time`
- ✅ 逻辑删除：`deleted`（0-未删除，1-已删除）

### 3. 接口规范

#### 3.1 RESTful API
- ✅ 遵循 RESTful 规范
- ✅ GET：查询，POST：新增，PUT：更新，DELETE：删除
- ✅ 统一返回格式：`{ success: boolean, message: string, code: number, data: T }`

#### 3.2 分页接口
- ✅ 请求参数：`pageNum`（当前页）、`pageSize`（每页数量）
- ✅ 返回格式：`{ list: T[], total: number }`

---

## 总结

**生成的代码必须：**
- ✅ 类型安全、无 `any`（尽量）
- ✅ 符合 Composition API 风格
- ✅ 遵循 ESLint 规范
- ✅ 包含完整的 TypeScript 类型注解
- ✅ 包含函数级 JSDoc 注释
- ✅ 符合项目代码风格和架构设计